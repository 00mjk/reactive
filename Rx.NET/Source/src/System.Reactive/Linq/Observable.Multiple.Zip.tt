// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT License.
// See the LICENSE file in the project root for more information. 

<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
namespace System.Reactive.Linq
{
    public static partial class Observable
    {
        /* The following code is generated by a T4 template. */

        #region Zip auto-generated code (<#=DateTime.Now#>)

<#
Func<string, string> toUpper = s => char.ToUpper(s[0]) + s.Substring(1);

string[] ordinals = new[] { "first", "second", "third", "fourth", "fifth", "sixth", "seventh", "eighth", "ninth", "tenth", "eleventh", "twelfth", "thirteenth", "fourteenth", "fifteenth", "sixteenth" };

for (int i = 3; i <= 16; i++)
{
    var parameters = string.Join(", ", Enumerable.Range(1, i).Select(j => "IObservable<TSource" + j + "> source" + j));
    var genArgs = string.Join(", ", Enumerable.Range(1, i).Select(j => "TSource" + j));
    var sources = string.Join(", ", Enumerable.Range(1, i).Select(j => "source" + j));
    var paramRefs = string.Join(" or ", Enumerable.Range(1, i).Select(j => "<paramref name=\"source" + j + "\"/>"));

#>
        /// <summary>
        /// Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.
        /// </summary>
<#
for (int j = 0; j < i; j++)
{
#>
        /// <typeparam name="TSource<#=j + 1#>">The type of the elements in the <#=ordinals[j]#> source sequence.</typeparam>
<#
}
#>
        /// <typeparam name="TResult">The type of the elements in the result sequence, returned by the selector function.</typeparam>
<#
for (int j = 0; j < i; j++)
{
#>
        /// <param name="source<#=j + 1#>"><#=toUpper(ordinals[j])#> observable source.</param>
<#
}
#>
        /// <param name="resultSelector">Function to invoke for each series of elements at corresponding indexes in the sources.</param>
        /// <returns>An observable sequence containing the result of combining elements of the sources using the specified result selector function.</returns>
        /// <exception cref="ArgumentNullException"><#=paramRefs#> or <paramref name="resultSelector"/> is null.</exception>
        public static IObservable<TResult> Zip<<#=genArgs#>, TResult>(this <#=parameters#>, Func<<#=genArgs#>, TResult> resultSelector)
        {
<#
for (int j = 0; j < i; j++)
{
#>
            if (source<#=j + 1#> == null)
            {
                throw new ArgumentNullException(nameof(source<#=j + 1#>));
            }

<#
}
#>
            if (resultSelector == null)
            {
                throw new ArgumentNullException(nameof(resultSelector));
            }

            return s_impl.Zip(<#=sources#>, resultSelector);
        }

<#
}
#>
        #endregion
    }
}
